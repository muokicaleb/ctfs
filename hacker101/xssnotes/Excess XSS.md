Excess XSS

*Summary study notes from [https://excess-xss.com](https://excess-xss.com)*


## Overview
Cross-site scripting (XSS) is a code injection attack that allows an attacker to execute malicious JavaScript in another user's browser.

The attacker only interacts with the vulnerable website. The vulerable website delivers the malicious script to the victim.

> The only way for the attacker to run his malicious JavaScript in the victim's browser is to inject it into one of the pages that the victim downloads from the website. This can happen if the website directly includes user input in its pages, because the attacker can then insert a string that will be treated as code by the victim's browser.


## What is malicious JavaScript
JavaScript can be malicious when you consider:
* Javascript has access to some user's sensitive information such as cookies.
* Javascript can send HTTP requests with arbitrary content to arbitrary destination bu using XMLHttpRequest and other mechanisms.
* Javascript can make arbitrary modifications to the HTML of the current page by using DOM manipulation methods.

## Consequences of malicious JavaScript
The types of attacks that can take places from malicious JavaScript:
* Cookie theft
* Keylogging
* Phishing

# XSS Attacks
## Actors in an xss attack.
* *The website* serves HTML pages to users who request them.
* *The victim* is a normal userr of the website who requests pages from it using his browser.
*  *The attacker* is a malicious user of the website who intends to launch an attack on the victim by exploiting an xss vulnerability in the website.


## Type of XSS
* Persistent XSS where the malicious string originates from the website's database.
* Reflected XSS Where the malicious string originates from the victim's request
* DOM-based XSS where the vulnerability is in the client-side code rather than the serrver-side code.

## Reflected XSS 
> In a reflected XSS attack, the malicious string is part of the victim's request to the website. The website then includes this malicious string in the response sent back to the user

The typical flow is :


   1. The attacker crafts a URL containing a malicious string and sends it to the victim.
  
  2.  The victim is tricked by the attacker into requesting the URL from the website.

   3. The website includes the malicious string from the URL in the response.

   4. The victim's browser executes the malicious script inside the response, sending the victim's cookies to the attacker's server.

### How can reflected XSS succeed?
> There are at least two common ways of causing a victim to launch a reflected XSS attack against himself:

 > * If the user targets a specific individual, the attacker can send the malicious URL to the victim (using e-mail or instant messaging, for example) and trick him into visiting it.
 > * If the user targets a large group of people, the attacker can publish a link to the malicious URL (on his own website or on a social network, for example) and wait for visitors to click it.

> These two methods are similar, and both can be more successful with the use of a URL shortening service, which masks the malicious string from users who might otherwise identify it.

## DOM-based XSS
> DOM-based XSS is a variant of both persistent and reflected XSS. In a DOM-based XSS attack, the malicious string is not actually parsed by the victim's browser until the website's legitimate JavaScript is executed. 

 1. The attacker crafts a URL containing a malicious string and sends it to the victim.

   2. The victim is tricked by the attacker into requesting the URL from the website.

   3. The website receives the request, but does not include the malicious string in the response.

   4. The victim's browser executes the legitimate script inside the response, causing the malicious script to be inserted into the page.

   5. The victim's browser executes the malicious script inserted into the page, sending the victim's cookies to the attacker's server.

The difference between DOM based XSS and the others are:
* In traditional XSS, the malicious JavaScript is executed when the page is loaded, as part of the HTML sent by the server.
* In DOM-based XSS, the malicious JavaScript is executed at some point after the page has loaded, as a result of the page's legitimate JavaScript treating user input in an unsafe way.

## Why DOM-based XSS matters

> In the previous example, JavaScript was not necessary; the server could have generated all the HTML by itself. If the server-side code were free of vulnerabilities, the website would then be safe from XSS.

> However, as web applications become more advanced, an increasing amount of HTML is generated by JavaScript on the client-side rather than by the server. Any time content needs to be changed without refreshing the entire page, the update must be performed using JavaScript. Most notably, this is the case when a page is updated after an AJAX request.

> This means that XSS vulnerabilities can be present not only in your website's server-side code, but also in your website's client-side JavaScript code. Consequently, even with completely secure server-side code, the client-side code might still unsafely include user input in a DOM update after the page has loaded. If this happens, the client-side code has enabled an XSS attack through no fault of the server-side code.

## DOM-based XSS invisible to the server
> There is a special case of DOM-based XSS in which the malicious string is never sent to the website's server to begin with: when the malicious string is contained in a URL's fragment identifier (anything after the # character). Browsers do not send this part of the URL to servers, so the website has no way of accessing it using server-side code. The client-side code, however, has access to it and can thus cause XSS vulnerabilities by handling it unsafely.

> This situation is not limited to fragment identifiers. Other user input that is invisible to the server includes new HTML5 features like LocalStorage and IndexedDB.

# Preventing XSS
## Methods of preventing XSS
In order to prevent this type of code injection, secure input handling is needed. For a web developer, there are two fundamentally different ways of performing secure input handling:

   * Encoding, which escapes the user input so that the browser interprets it only as data, not as code.

   * Validation, which filters the user input so that the browser interprets it as code without malicious commands.

While these are fundamentally different methods of preventing XSS, they share several common features that are important to understand when using either of them:

> * Context
Secure input handling needs to be performed differently depending on where in a page the user input is inserted.

> * Inbound/outbound
Secure input handling can be performed either when your website receives the input (inbound) or right before your website inserts the input into a page (outbound).

> * Client/server
Secure input handling can be performed either on the client-side or on the server-side, both of which are needed under different circumstances.
